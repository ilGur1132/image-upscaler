!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("@upscalerjs/default-model"),require("@tensorflow/tfjs-core"),require("@tensorflow/tfjs")):"function"==typeof define&&define.amd?define(["@upscalerjs/default-model","@tensorflow/tfjs-core","@tensorflow/tfjs"],t):(e="undefined"!=typeof globalThis?globalThis:e||self).Upscaler=t(e.DefaultUpscalerJSModel,e.tf,e.tf)}(this,function(e,t,o){"use strict";function r(o){var r=Object.create(null);return o&&Object.keys(o).forEach(function(e){var t;"default"!==e&&(t=Object.getOwnPropertyDescriptor(o,e),Object.defineProperty(r,e,t.get?t:{enumerable:!0,get:function(){return o[e]}}))}),r.default=o,Object.freeze(r)}var n,P=r(t),i=r(o);(t=n=n||{}).UNDEFINED="undefined",t.INVALID_MODEL_TYPE="invalidModelType",t.MISSING_PATH="missingPath";const s=e=>!(!Boolean(e)||!Array.isArray(e)||4!==e.length)&&e.every(e=>null===e||"number"==typeof e),l=e=>s(e)&&null!==e[1]&&null!==e[2]&&0<e[1]&&0<e[2];function a(t){return function(e){try{return e.shape.length===t}catch(e){}return!1}}const d=a(4),$=a(3),c=e=>e instanceof P.Tensor,U=e=>"string"==typeof e,q=e=>"string"==typeof e&&["layers","graph"].includes(e);class p extends Error{type;constructor(e){super(e),this.type=e}}const B=e=>"number"==typeof e,u=e=>Array.isArray(e)&&2===e.length&&e.every(B),_=e=>{console.warn(Array.isArray(e)?e.join("\n"):e)};function T(e){return void 0!==e&&"function"==typeof e}async function h(e,t){let o;for(o=await e.next();!o.done;o=await e.next())t&&await t(o.value);return o.value}function m(e){return null!=e}function O(e,t,...o){const r=o.filter(m);return r.length?(o=e.tidy(()=>r.reduce((e,t)=>t(e),t)),t.isDisposed||t===o||t.dispose(),o):t}const C=["Passing a model definition as a function is deprecated and will be removed in a future version.","To leverage model lifecycle methods, use the setup and teardown methods.","For more information, see https://upscalerjs.com/documentation/troubleshooting#deprecated-model-definition-function."].join(" ");const J=['"padding" is undefined, but "patchSize" is explicitly defined.',"Without padding, patches of images often have visible artifacting at the seams. Defining an explicit padding will resolve the artifacting.","For more information, see https://upscalerjs.com/documentation/troubleshooting#padding-is-undefined.",'To hide this warning, pass an explicit padding of "0".'].join(" ");const L=['The "progress" callback was provided but "patchSize" was not defined.','Without a "patchSize", the "progress" callback will never be called.',"For more information, see https://upscalerjs.com/documentation/troubleshooting#progress-specified-without-patch-size."].join(" "),V=e=>[`The tensor returned by the model was not a valid rank-4 tensor. It's shape is ${JSON.stringify(e)}.}`,"UpscalerJS only supports models returning valid image-like data in four dimensional form.","For more information, see https://upscalerjs.com/documentation/troubleshooting#invalid-predicted-tensor."].join(" ");const R=["The model output was not a valid tensor. UpscalerJS only supports models returning valid tensors.","This is likely an error with the model itself, not UpscalerJS.","For more information, see https://upscalerjs.com/documentation/troubleshooting#invalid-model-prediction."].join(" "),Y=new Error("No defined tensors were passed to concatTensors");class f extends Error{message="The upscale request received an abort signal"}const G=e=>[`You've provided an invalid model type: ${JSON.stringify(e)}. Accepted types are "layers" and "graph".`,"For more information, see https://upscalerjs.com/documentation/troubleshooting#invalid-model-type."].join(" "),g="There is a bug with the upscaler code. Please report this.",H=["You have provided a patchSize, but the model definition already includes an input size.","Your patchSize will be ignored.","For more information, see https://upscalerjs.com/documentation/troubleshooting#input-size-and-patch-size."].join(" "),W=e=>new Error([`Invalid patch size: ${e}. Patch size must be greater than 0.`].join(" ")),K=(e,t)=>new Error([`Invalid patch size and padding: ${e} and ${t}. Patch size must be greater than padding * 2.`].join(" ")),Q=(e,t,o)=>[`Invalid patch size: ${e}. The model has a defined divibility factor of ${t} and patch size must be a multiple of this number.`,`Patch size has been scaled up to ${o}.`,`
For more information, see https://upscalerjs.com/documentation/troubleshooting#patch-size-indivisible-by-divisibility-factor.`].join(" "),X=new Error(["Model input sizes must be square. If you are using a model with a non-square input size and would like to request support,","please file a feature request at https://github.com/thekevinscott/upscalerjs"].join(" ")),Z=e=>['Provided model configuration is missing both a "path" and "_internals". A valid path to a model JSON file must be provided.',"For more information, see https://upscalerjs.com/documentation/troubleshooting#missing-path-and-internals.","The model configuration provided was: "+JSON.stringify(e)].join(" ");const y=(o,r,n)=>async e=>{if(n&&await o.nextFrame(),(t=r)&&t.aborted)throw Array.isArray(e)?e.forEach(e=>e?.dispose()):c(e)&&e.dispose(),new f;var t},w=e=>!(!e||"object"!=typeof e)&&"patchSize"in e&&"number"==typeof e.patchSize,v=e=>Boolean(e)&&"number"==typeof e&&0<e,ee=e=>["Invalid value passed to warmup in warmupSizes:",JSON.stringify(e),"For more information, see https://upscalerjs.com/documentation/troubleshooting#invalid-warmup-value."].join("\n"),b=e=>new Error(ee(e)),te=e=>{var t;return w(e)?(t=e["patchSize"],t):e};const oe=e=>{if(Array.isArray(e)){for(const t of e)if(!w(t)&&!v(t))throw b(e);return e}if(w(e)||v(e))return[e];throw b(e)},z=async(e,t,o,{signal:r=void 0,awaitNextFrame:n=!1}={},i)=>{r=y(e,r||i.signal,n);await r(),await h(async function*(t,e,o){const{model:r,modelDefinition:n}=await e;for(const s of o){if(!w(s)&&!v(s))throw b(s);var i=te(s);let e=t.zeros([1,i,i,3]);yield[e];for(const a of[n.preprocess,e=>r.predict(e),n.postprocess].filter(Boolean))yield[e=O(t,e,a)];e.dispose(),yield}}(e,t,oe(o)),r)};async function re(e,t){o=e;var o="function"==typeof(t=t)?(_(C),t(o)):t;return o.setup&&await o.setup(e),o}function j(e,t,o){return"graph"===o?e.loadGraphModel(t):e.loadLayersModel(t)}const ne=(e,{model:t})=>{e=(t=t)instanceof e.LayersModel?t.layers[0].batchInputShape:t.inputs[0].shape;if(s(e))return e;throw new Error([`Expected model to have a rank-4 compatible input shape. Instead got: ${JSON.stringify(e)}.`,"For more information, see https://upscalerjs.com/documentation/troubleshooting#error-with-model-input-shape."].join(" "))},E=(e,t)=>Math.ceil(t/e)*e,ie=(e,t,{patchSize:o,padding:r},n)=>{e=ne(e,t);if(void 0!==o){if(o<=0)throw W(o);if(void 0!==r&&o<=2*r)throw K(o,r)}if(l(e)){if(void 0!==o&&_(H),e[1]!==e[2])throw X;return{patchSize:e[1],padding:r,modelInputShape:e}}void 0!==o&&void 0===r&&_(J);e=t.modelDefinition.divisibilityFactor;return void 0!==e?void 0!==o?((t=E(e,o))!==o&&_(Q(o,e,t)),{patchSize:t,padding:r,modelInputShape:[null,t,t,3]}):{patchSize:void 0,padding:void 0,modelInputShape:[null,E(e,n[1]),E(e,n[2]),3]}:{patchSize:o,padding:r,modelInputShape:void 0}},se=(s,a)=>r=>{const n=r.shape[1],i=r.shape[2];return l(a)&&(a[1]>n||a[2]>i)?s.tidy(()=>{var e=Math.max(n,a[1]),t=Math.max(i,a[2]),o=s.zeros([1,n,t-i,3]),e=s.zeros([1,e-n,t,3]),t=s.concat([r,o],2);return s.concat([t,e],1)}):r},D=(r,n,i)=>e=>{const t=n[1]*i,o=n[2]*i;return t<e.shape[1]||o<e.shape[2]?r.tidy(()=>r.slice(e,[0,0,0],[1,t,o,3])):e},x=o=>e=>{var t=u(o)?o[1]:255;return e.clipByValue(0,t).mul(1===t?255:1)},ae=(t,o)=>e=>u(o)&&1===o[1]?t.mul(e,1/255):e;function F(e,t,o=0){var r=t.filter(m);if(0===r.length)throw Y;e=e.concat(r,o);return t.forEach(e=>e?.dispose()),e}const S=(e,t,o,r)=>{let n=t;var t=0===t||o===e?0:r,i=n+o>e,s=i?o-(e-n):0,r=i||o===e?0:r,a=i?0:t,l=o-(i?s:0),i=(i&&(n=e-o),s+=a,l-=a+r,e<o?e:o-t-r);return{pre:{origin:n-=a,size:o},post:{origin:s,size:l},increment:i}},N=([e,t],o,r)=>{var n=[];let i=0,s=0;for(;s<t;){for(var{pre:{origin:a,size:l},post:{origin:d,size:p},increment:u}=S(t,s,Math.min(o,t),r),c=[];i<e;){var{pre:{origin:h,size:m},post:{origin:f,size:g},increment:y}=S(e,i,Math.min(o,e),r);c.push({pre:{origin:[a,h],size:[l,m]},post:{origin:[d,f],size:[p,g]}}),i+=y}n.push(c),i=0,s+=u}return n},M=(e,t)=>{e=e.predict(t);if(!c(e))throw new Error(R);if(d(e))return e;throw new Error(V(e.shape))};async function*le(n,i,{output:s,progress:a,progressOutput:l},e,{originalImageSize:t,patchSize:o,padding:d=0},{tensorAsBase64:p}){var{model:u,modelDefinition:c}=e,h=c.scale??1;if(o){var[e,m]=i.shape.slice(1),f=N([m,e],o,d);yield;let r;var g=f.length*f[0].length;for(let o=0;o<f.length;o++){var y=f[o],w=y.length;let t;yield[t,r];for(let e=0;e<w;e++){var{pre:v,post:b}=y[e],z=(yield[r,t],i.slice([0,...v.origin],[-1,...v.size]));yield[r,t,z];const I=M(u,z);z.dispose(),yield[r,t,I];var z=[0,b.origin[0]*h,b.origin[1]*h],j=[-1,b.size[0]*h,b.size[1]*h],z=I.slice(z,j),j=(I.dispose(),yield[r,t,z],O(n,z,c.postprocess,x(c.outputRange)));if(yield[r,t,j],void 0!==a&&T(a)){z=o,S=e;z=(z*w+S+1)/g;if(T(S=a)&&S.length<=1)a(z);else{const A=j.squeeze();var E,S={row:o,col:e,patchCoordinates:{pre:v,post:b}};v=s,b=l,!T(E=a)||E.length<=1||(void 0!==b||"tensor"!==v)&&"tensor"!==b?(E=p(n,A),A.dispose(),a(z,E,S)):a(z,A,S)}}yield[r,t,j],t=F(n,[t,j],2),j.dispose(),yield[r,t]}r=F(n,[r,t],1),t.dispose(),yield[r]}m=O(n,r.clone(),D(n,t,h));r?.dispose(),yield[m];const A=m.squeeze();return m.dispose(),A}a&&_(L);const I=M(u,i);yield[I];e=O(n,I.clone(),c.postprocess,x(c.outputRange),D(n,t,h));I.dispose(),yield[e];const A=e.squeeze();return e.dispose(),A}async function*de(e,t,o,r,{getImageAsTensor:n,tensorAsBase64:i}){t=t;var n=await n(e,c(t)?t.clone():t),t=(yield n,n.shape),{patchSize:s,padding:a,modelInputShape:l}=ie(e,r,o,t),d=O(e,n,r.modelDefinition.preprocess,ae(e,r.modelDefinition.inputRange),l?se(e,l):void 0),p=(yield d,le(e,d,{output:o.output,progressOutput:o.progressOutput,progress:o.progress},r,{originalImageSize:t,patchSize:s,padding:a},{tensorAsBase64:i}));let u=await p.next();for(yield u.value;!u.done;)u=await p.next(),Array.isArray(u.value)?yield[...u.value,d]:c(u.value)?yield[u.value,d]:yield d;d.dispose();n=u.value;return"tensor"===o.output?n:(l=i(e,n),n.dispose(),l)}const pe=e;const I=e=>"tensor"===e?"tensor":"base64";const ue={jsdelivr:(e,t,o)=>`https://cdn.jsdelivr.net/npm/${e}@${t}/`+o,unpkg:(e,t,o)=>`https://unpkg.com/${e}@${t}/`+o},ce=["jsdelivr","unpkg"],he=(e,t,o)=>new Error([`Could not resolve URL ${t} for package ${o?.name}@`+o?.version,"Errors include:",...e.map(([e,t])=>`- ${e}: `+t.message)].join("\n"));const me="https://upscalerjs.com/documentation/troubleshooting#environment-disallows-base64",fe="https://upscalerjs.com/documentation/troubleshooting#environment-disallows-string-input",ge=()=>new Error(["Environment does not support a string URL as an input format.",`For more information, see ${fe}.`].join("\n")),ye=()=>new Error(["Environment does not support base64 as an output format.",`For more information, see ${me}.`].join("\n")),we=r=>new Promise((e,t)=>{const o=new Image;o.src=r,o.crossOrigin="anonymous",o.onload=()=>e(o),o.onerror=()=>t(new Error(["Failed to load image"].join(" ")))}),A=e=>i.browser.fromPixelsAsync(e);const k=t=>{try{if(!0!==(new Image&&"createElement"in document))throw t()}catch(e){throw t()}};o=function({tf:n,getUpscaleOptions:i,checkValidEnvironment:s,getImageAsTensor:a,tensorAsBase64:l,loadModel:t}){return class{_opts;_model;ready;_abortController=new AbortController;constructor(e={}){this._opts={...e},this._model=t(n,re(n,this._opts.model||pe)),this.ready=new Promise((e,t)=>{this._model.then(()=>z(n,this._model,this._opts.warmupSizes||[],void 0,{signal:this._abortController.signal})).then(e).catch(t)})}async execute(e,t){var o={checkValidEnvironment:s,getImageAsTensor:a,tensorAsBase64:l},r=(await this.ready,await this._model);return async function(e,t,{signal:o,awaitNextFrame:r,...n},i,{checkValidEnvironment:s,...a}){return s(t,{output:n.output,progressOutput:n.progressOutput}),await(s=y(e,o||i.signal,r))(),o=await h(de(e,t,n,i,a),s),await s(),o}(n,e,i(t),{...r,signal:this._abortController.signal},o)}upscale=this.execute.bind(this);warmup=async(e=[],t)=>(await this.ready,z(n,this._model,e,t,{signal:this._abortController.signal}));abort=()=>{this._abortController.abort(),this._abortController=new AbortController};dispose=async()=>{await this.ready;var{model:e,modelDefinition:t}=await this._model;t.teardown&&await t.teardown(n),e.dispose()};getModel=()=>this._model}}({tf:i,getUpscaleOptions:({output:e,progressOutput:t,...o}={})=>({...o,output:I(e),progressOutput:I(t||e)}),loadModel:async(e,t)=>{t=await t;try{(e=>{if(void 0===e)throw new p(n.UNDEFINED);if(!q(e.modelType??"layers"))throw new p(n.INVALID_MODEL_TYPE);if(e.path||e._internals?.path)return;throw new p(n.MISSING_PATH)})(t)}catch(e){if(e instanceof p)throw function(e,t){switch(e){case n.INVALID_MODEL_TYPE:return new Error(G(t?.modelType));case n.MISSING_PATH:return new Error(Z(t));default:return new Error(g)}}(e.type,t);throw new Error(g)}t={...t};return{model:await async function(e,t){var{modelType:o,_internals:r,path:t}=t;if(t)return j(e,t,o);if(!r)throw new Error(g);var n=[];for(const s of ce){var i=ue[s];try{return await j(e,i(r.name,r.version,r.path),o)}catch(e){n.push([s,e instanceof Error?e:new Error("There was an unknown error: "+JSON.stringify(e))])}}throw he(n,t||r.path,r)}(e,t),modelDefinition:t}},getImageAsTensor:async(e,t)=>{t=t;var o=await(c(t)?t:U(t)?(o=await we(t),A(o)):A(t));if($(o))return t=o.expandDims(0),o.dispose(),t;if(d(o))return o;throw new Error([`Unsupported dimensions for incoming pixels: ${o.shape.length}.`,"Only 3 or 4 rank tensors are supported."].join("\n"))},tensorAsBase64:(e,t)=>{r=t;var o,r,e=(o=e).tidy(()=>{var[e,t]=r.shape,e=o.fill([e,t],255).expandDims(2);return r.clipByValue(0,255).concat([e],2).dataSync()}),[t,n]=t.shape,i=new ImageData(n,t),e=(i.data.set(e),document.createElement("canvas")),n=(e.width=n,e.height=t,e.getContext("2d"));if(n)return n.putImageData(i,0,0),e.toDataURL();throw new Error("No context found")},checkValidEnvironment:(e,{output:t="base64",progressOutput:o})=>{"string"==typeof e&&k(ge),"base64"!==o&&"base64"!==t||k(ye)}});return o.getPatchesFromImage=N,o.AbortError=f,o});