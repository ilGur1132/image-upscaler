!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("@tensorflow/tfjs"),require("@upscalerjs/default-model"),require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["@tensorflow/tfjs","@upscalerjs/default-model","@tensorflow/tfjs-core"],t):(e="undefined"!=typeof globalThis?globalThis:e||self).Upscaler=t(e.tf,e.DefaultUpscalerJSModel,e.tf)}(this,function(e,t,k){"use strict";function P(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function o(o){if(o&&o.__esModule)return o;var r=Object.create(null);return o&&Object.keys(o).forEach(function(e){var t;"default"!==e&&(t=Object.getOwnPropertyDescriptor(o,e),Object.defineProperty(r,e,t.get?t:{enumerable:!0,get:function(){return o[e]}}))}),r.default=o,Object.freeze(r)}var r,d=o(e),e=P(t),C=o(k);const n=e=>{if(!Boolean(e)||!Array.isArray(e)||4!==e.length)return!1;for(const t of e)if(null!==t&&"number"!=typeof t)return!1;return!0};function i(t){return function(e){try{return e.shape.length===t}catch(e){}return!1}}const s=i(4),a=i(3),u=e=>e instanceof C.Tensor,L=e=>"string"==typeof e,U=e=>"string"==typeof e&&["layers","graph"].includes(e);(t=r=r||{}).UNDEFINED="undefined",t.INVALID_MODEL_TYPE="invalidModelType",t.MISSING_PATH="missingPath";class l extends Error{type;constructor(e){super(e),this.type=e}}const J=e=>{if(void 0===e)throw new l(r.UNDEFINED);if(!U(e.modelType||"layers"))throw new l(r.INVALID_MODEL_TYPE);if(e.path)return!0;throw new l(r.MISSING_PATH)},q=e=>"number"==typeof e,c=e=>Array.isArray(e)&&2===e.length&&e.every(q),B=e=>e instanceof d.LayersModel;class p extends Error{message="The upscale request received an abort signal"}const R="https://upscalerjs.com/documentation/troubleshooting#invalid-model-type";const Y="https://upscalerjs.com/documentation/troubleshooting#error-with-model-input-shape",H=['You must provide a "path" when providing a model definition',"For more information, see https://upscalerjs.com/documentation/troubleshooting#missing-model-path."].join("\n"),V=e=>[`You've provided an invalid model type: ${JSON.stringify(e)}. Accepted types are "layers" and "graph".`,`For more information, see ${R}.`].join("\n"),h="There is a bug with the upscaler code. Please report this.",G=["You have provided a patchSize, but the model definition already includes an input size.","Your patchSize will be ignored.","For more information, see https://upscalerjs.com/documentation/troubleshooting#input-size-and-patch-size."].join("\n"),W=e=>[`Expected model to have a rank-4 compatible input shape. Instead got: ${JSON.stringify(e)}.`,`For more information, see ${Y}.`].join("\n");const D=e=>{console.warn(Array.isArray(e)?e.join("\n"):e)};function x(e){return void 0!==e&&"function"==typeof e}const K=(e,t,o)=>!(!x(e)||e.length<=1)&&(void 0===o&&"tensor"===t||"tensor"===o),Q=e=>!!e&&e.aborted;async function f(e,t){let o;for(o=await e.next();!o.done;o=await e.next())t&&await t(o.value);return o.value}const X=o=>d.tidy(()=>{var[e,t]=o.shape,e=d.fill([e,t],255).expandDims(2);return o.clipByValue(0,255).concat([e],2).dataSync()});function Z(e){return null!=e}function I(e,...t){const o=t.filter(Z);return o.length?(t=d.tidy(()=>o.reduce((e,t)=>t(e),e)),e.isDisposed||e===t||e.dispose(),t):e}async function m(e,t="layers"){return"graph"===t?d.loadGraphModel(e):d.loadLayersModel(e)}const ee=e=>B(e)?e.layers[0].batchInputShape:e.inputs[0].shape,g=e=>{e=ee(e);if(n(e))return e;throw new Error(W(e))},te=t=>e=>c(t)&&1===t[1]?d.mul(e,1/255):e,w=e=>Boolean(e)&&n(e)&&Boolean(e[1])&&Boolean(e[2]),oe=(e,{patchSize:t,padding:o})=>{e=g(e);if(w(e)&&void 0!==t&&D(G),w(e)){if(e[1]!==e[2])throw new Error("Input shape must be square");return{patchSize:e[1]-2*(o||0),padding:o}}return{patchSize:t,padding:o}},re=s=>r=>{const n=r.shape[1],i=r.shape[2];return w(s)&&(s[1]>n||s[2]>i)?d.tidy(()=>{var e=Math.max(n,s[1]),t=Math.max(i,s[2]),o=d.zeros([1,n,t-i,3]),e=d.zeros([1,e-n,t,3]),t=d.concat([r,o],2);return d.concat([t,e],1)}):r},O=(r,n)=>e=>{const t=r[1]*n,o=r[2]*n;return t<e.shape[1]||o<e.shape[2]?d.tidy(()=>d.slice(e,[0,0,0],[1,t,o,3])):e},T=o=>e=>{var t=c(o)?o[1]:255;return e.clipByValue(0,t).mul(1===t?255:1)},y=e=>"tensor"===e?"tensor":"base64";const ne={jsdelivr:(e,t,o)=>`https://cdn.jsdelivr.net/npm/${e}@${t}/`+o,unpkg:(e,t,o)=>`https://unpkg.com/${e}@${t}/`+o},v=["jsdelivr","unpkg"],ie=(e,t,o)=>new Error([`Could not resolve URL ${e} for package ${t.name}@`+t.version,"Errors include:",...o.map(([e,t])=>`- ${e}: `+t.message)].join("\n")),se=async({path:t,modelType:o,packageInformation:r})=>{if(r){const i=[];for(let e=0;e<v.length;e++){var n=v[e];const s=ne[n];try{return await m(s(r.name,r.version,t),o)}catch(e){i.push([n,e instanceof Error?e:new Error("There was an unknown error: "+JSON.stringify(e))])}}throw ie(t,r,i)}return m(t,o)},ae=async t=>{try{J(t)}catch(e){throw e instanceof l?function(e,t){switch(e){case r.MISSING_PATH:return new Error(H);case r.INVALID_MODEL_TYPE:return new Error(V(t?.modelType));default:return new Error(h)}}(e.type,t):new Error(h)}return{model:await se(t),modelDefinition:t}},b=(t,o)=>async e=>{if(o&&await d.nextFrame(),Q(t))throw Array.isArray(e)?e.forEach(e=>e?.dispose()):u(e)&&e.dispose(),new p},E=e=>!(!e||"object"!=typeof e)&&("patchSize"in e&&"number"==typeof e.patchSize),j=e=>Boolean(e)&&Array.isArray(e)&&2===e.length&&"number"==typeof e[0]&&"number"==typeof e[1],le="https://upscalerjs.com/documentation/troubleshooting#invalid-warmup-value",de=e=>["Invalid value passed to warmup in warmupSizes:",JSON.stringify(e),`For more information, see ${le}.`].join("\n"),S=e=>new Error(de(e)),ue=e=>{var t,o;return E(e)?({patchSize:o,padding:t=0}=e,[o=o+2*t,o]):e};const ce=e=>{if(Array.isArray(e)){if(j(e))return[e];for(const t of e)if(!E(t)&&!j(t))throw S(t);return e}if(E(e))return[e];throw S(e)},z=async(e,t,{signal:o=void 0,awaitNextFrame:r=!1}={},n)=>{const i=b(o||n.signal,r);await i(),await f(async function*(e,t){const{model:o,modelDefinition:r}=await e;for(const l of t){if(!E(l)&&!j(l))throw S(l);var[n,i]=ue(l);let t=d.zeros([1,i,n,3]);yield[t];var s=[r.preprocess,e=>o.predict(e),r.postprocess].filter(Boolean);for(let e=0;e<s.length;e++){var a=s[e];yield[t=I(t,a)]}t.dispose(),yield}}(e,ce(t)),i)},pe="https://upscalerjs.com/documentation/troubleshooting#environment-disallows-base64",he="https://upscalerjs.com/documentation/troubleshooting#environment-disallows-string-input",fe=()=>new Error(["Environment does not support a string URL as an input format.",`For more information, see ${he}.`].join("\n")),me=()=>new Error(["Environment does not support base64 as an output format.",`For more information, see ${pe}.`].join("\n")),ge=e=>new Error([`Unsupported dimensions for incoming pixels: ${e.shape.length}.`,"Only 3 or 4 rank tensors are supported."].join("\n")),we=()=>new Error(["Failed to load image"].join(" ")),ye=r=>new Promise((e,t)=>{const o=new Image;o.src=r,o.crossOrigin="anonymous",o.onload=()=>e(o),o.onerror=()=>t(we())}),_=e=>d.browser.fromPixelsAsync(e),ve=async e=>{return u(e)?e:L(e)?(t=await ye(e),_(t)):_(e);var t},be=async e=>{const t=await ve(e);if(a(t))return e=t.expandDims(0),t.dispose(),e;if(s(t))return t;throw ge(t)},N=e=>{var t=X(e),[e,o]=e.shape;const r=new ImageData(o,e),n=(r.data.set(t),document.createElement("canvas")),i=(n.width=o,n.height=e,n.getContext("2d"));if(i)return i.putImageData(r,0,0),n.toDataURL();throw new Error("No context found")},A=t=>{try{new Image&&0 in document}catch(e){throw t()}},Ee=(e,{output:t="base64",progressOutput:o})=>{"string"==typeof e&&A(fe),"base64"!==o&&"base64"!==t||A(me)};const je=['"padding" is undefined, but "patchSize" is explicitly defined.',"Without padding, patches of images often have visible artifacting at the seams. Defining an explicit padding will resolve the artifacting.","For more information, see https://upscalerjs.com/documentation/troubleshooting#padding-is-undefined.",'To hide this warning, pass an explicit padding of "0".'].join("\n");const Se=['The "progress" callback was provided but "patchSize" was not defined.','Without a "patchSize", the "progress" callback will never be called.',"For more information, see https://upscalerjs.com/documentation/troubleshooting#progress-specified-without-patch-size."].join("\n"),ze="https://upscalerjs.com/documentation/troubleshooting#invalid-predicted-tensor",_e=e=>[`The tensor returned by the model was not a valid rank-4 tensor. It's shape is ${JSON.stringify(e.shape)}.}`,"UpscalerJS only supports models returning valid image-like data in four dimensional form.",`For more information, see ${ze}.`].join("\n");const Ae=["The model output was not a valid tensor. UpscalerJS only supports models returning valid tensors.","This is likely an error with the model itself, not UpscalerJS.","For more information, see https://upscalerjs.com/documentation/troubleshooting#invalid-model-prediction."].join("\n"),De=e=>new Error("Invalid shape provided to getWidthAndHeight, expected tensor of rank 3 or 4: "+JSON.stringify(e.shape)),xe=()=>new Error("No defined tensors were passed to concatTensors"),Ie=e=>{if(s(e))return[e.shape[1],e.shape[2]];if(a(e))return[e.shape[0],e.shape[1]];throw De(e)},F=(e,t)=>{var[e,o]=Ie(e);return{rows:Math.ceil(e/t),columns:Math.ceil(o/t)}},M=(e,t,o)=>{var r;t[e]<0&&(r=0-t[e],t[e]+=r,o[e]-=r)},Oe=(t,o,r,n,i,s)=>{if(r[o]>t){t=r[o]-t;let e=0;n[o]-t<0&&(e=0-(n[o]-t)),n[o]-=t-e,r[o]-=t;n=t-e;i[o]+=n,s[o]+=n}},Te=(e,t,o)=>{o[e]>t[e]&&(o[e]=t[e])},Ne=new Error("Row is undefined"),Fe=new Error("Column is undefined"),Me=new Error("Patch Size is undefined"),$e=new Error("Height is undefined"),ke=new Error("Width is undefined"),Pe=({row:e,col:t,patchSize:o,height:r,width:n,padding:i=0})=>{if(void 0===e)throw Ne;if(void 0===t)throw Fe;if(void 0===o)throw Me;if(void 0===r)throw $e;if(void 0===n)throw ke;let s=o,a=o;s>r&&(s=r),a>n&&(a=n);e=[e*o-i,t*o-i],t=[i,i],M(0,e,t),M(1,e,t),o=[e[0]+s+2*i,e[1]+a+2*i],i=[t[0]+s,t[1]+a],Oe(r,0,o,e,t,i),Oe(n,1,o,e,t,i),r=[o[0]-e[0],o[1]-e[1]],Te(0,r,i),Te(1,r,i),n=[i[0]-t[0],i[1]-t[1]];return{origin:e,sliceOrigin:t,size:r,sliceSize:n}};function Ce(t,e=0){const o=[];for(let e=0;e<t.length;e++){var r=t[e];void 0!==r&&o.push(r)}if(0===o.length)throw xe();e=d.concat(o,e);return t.forEach(e=>e?.dispose()),e}const Le=(e,t,o,r)=>{return(e*o+t+1)/r},Ue=(e,t)=>{e=e.predict(t);if(!u(e))throw new Error(Ae);if(s(e))return e;throw new Error(_e(e))};async function*Je(n,{output:i,progress:s,patchSize:a,padding:l,progressOutput:d},{model:u,modelDefinition:c},{imageSize:e,inputSize:t}){var p=c.scale||1;if(void 0===t&&a&&void 0===l&&D(je),a){var[h,f]=n.shape.slice(1),{rows:m,columns:g}=F(n,a);yield;let r;var w=m*g;for(let o=0;o<m;o++){let t;yield[t,r];for(let e=0;e<g;e++){var{origin:y,size:v,sliceOrigin:b,sliceSize:E}=Pe({row:o,col:e,patchSize:a,padding:l,height:h,width:f});yield[r,t];const _=n.slice([0,y[0],y[1]],[-1,v[0],v[1]]),j=(yield[r,t,_],Ue(u,_));_.dispose(),yield[r,t,j];var y=[0,b[0]*p,b[1]*p],v=[-1,E[0]*p,E[1]*p],b=j.slice(y,v);j.dispose(),yield[r,t,b];const A=I(b,c.postprocess,T(c.outputRange));if(yield[r,t,A],void 0!==s&&x(s)){E=Le(o,e,g,w);if(x(y=s)&&y.length<=1)s(E);else{const S=A.squeeze();K(s,i,d)?s(E,S,o,e):(v=N(S),S.dispose(),s(E,v,o,e))}}yield[r,t,A],t=Ce([t,A],2),A.dispose(),yield[r,t]}r=Ce([r,t],1),t.dispose(),yield[r]}const z=I(r.clone(),O(e,p)),S=(r?.dispose(),yield[z],z.squeeze());return z.dispose(),S}s&&D(Se);const j=u.predict(n),o=(yield[j],I(j.clone(),c.postprocess,T(c.outputRange),O(e,p))),S=(j.dispose(),yield[o],o.squeeze());return o.dispose(),S}const qe=e=>u(e)?e.clone():e;async function Be(e,{signal:t,awaitNextFrame:o,...r},n){Ee(e,{output:r.output,progressOutput:r.progressOutput});const i=b(t||n.signal,o);await i();t=await f(async function*(e,t,{model:o,modelDefinition:r}){var e=qe(e),n=(yield e=await be(e),e.shape),i=g(o);const s=I(e,r.preprocess,te(r.inputRange),re(i)),a=(yield s,Je(s,t,{model:o,modelDefinition:r},{imageSize:n,inputSize:i}));let l=await a.next();for(yield l.value;!l.done;)l=await a.next(),Array.isArray(l.value)?yield[...l.value,s]:u(l.value)?yield[l.value,s]:yield s;s.dispose();const d=l.value;return"tensor"===t.output?d:(e=N(d),d.dispose(),e)}(e,r,n),i);return await i(),t}const Re=e.default;class ${_opts;_model;ready;_abortController=new AbortController;constructor(e={}){this._opts={...e},this._model=ae("function"==typeof(e=this._opts.model||Re)?e(d):e),this.ready=new Promise((e,t)=>{this._model.then(()=>z(this._model,this._opts.warmupSizes||[],void 0,{signal:this._abortController.signal})).then(e).catch(t)})}async execute(e,t){await this.ready;var o,r,{model:n,modelDefinition:i}=await this._model;return Be(e,([e,{output:t,progressOutput:o,...r}={}]=[n,t],{...r,...oe(e,r),output:y(t),progressOutput:y(o||t)}),{model:n,modelDefinition:i,signal:this._abortController.signal})}upscale=this.execute.bind(this);warmup=async(e=[],t)=>(await this.ready,z(this._model,e,t,{signal:this._abortController.signal}));abort=()=>{this._abortController.abort(),this._abortController=new AbortController};dispose=async()=>{await this.ready;const e=(await this._model)["model"];e.dispose()};getModel=()=>this._model}return $.getRowsAndColumns=F,$.getTensorDimensions=Pe,$.AbortError=p,$});